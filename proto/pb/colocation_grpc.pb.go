// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: colocation.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ColocationService_CreateColocation_FullMethodName     = "/coloc.ColocationService/CreateColocation"
	ColocationService_GetColocation_FullMethodName        = "/coloc.ColocationService/GetColocation"
	ColocationService_ListColocations_FullMethodName      = "/coloc.ColocationService/ListColocations"
	ColocationService_UpdateColocation_FullMethodName     = "/coloc.ColocationService/UpdateColocation"
	ColocationService_DeleteColocation_FullMethodName     = "/coloc.ColocationService/DeleteColocation"
	ColocationService_JoinColocation_FullMethodName       = "/coloc.ColocationService/JoinColocation"
	ColocationService_LeaveColocation_FullMethodName      = "/coloc.ColocationService/LeaveColocation"
	ColocationService_GetMembers_FullMethodName           = "/coloc.ColocationService/GetMembers"
	ColocationService_RemoveMember_FullMethodName         = "/coloc.ColocationService/RemoveMember"
	ColocationService_UpdateMemberRole_FullMethodName     = "/coloc.ColocationService/UpdateMemberRole"
	ColocationService_RegenerateInviteCode_FullMethodName = "/coloc.ColocationService/RegenerateInviteCode"
	ColocationService_SendInvitation_FullMethodName       = "/coloc.ColocationService/SendInvitation"
	ColocationService_ListInvitations_FullMethodName      = "/coloc.ColocationService/ListInvitations"
	ColocationService_CancelInvitation_FullMethodName     = "/coloc.ColocationService/CancelInvitation"
)

// ColocationServiceClient is the client API for ColocationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ColocationService handles colocation operations
type ColocationServiceClient interface {
	// Create a new colocation
	CreateColocation(ctx context.Context, in *CreateColocationRequest, opts ...grpc.CallOption) (*Colocation, error)
	// Get colocation by ID
	GetColocation(ctx context.Context, in *GetColocationRequest, opts ...grpc.CallOption) (*Colocation, error)
	// List user's colocations
	ListColocations(ctx context.Context, in *ListColocationsRequest, opts ...grpc.CallOption) (*ListColocationsResponse, error)
	// Update colocation (admin only)
	UpdateColocation(ctx context.Context, in *UpdateColocationRequest, opts ...grpc.CallOption) (*Colocation, error)
	// Delete colocation (admin only)
	DeleteColocation(ctx context.Context, in *DeleteColocationRequest, opts ...grpc.CallOption) (*DeleteColocationResponse, error)
	// Join colocation with invite code
	JoinColocation(ctx context.Context, in *JoinColocationRequest, opts ...grpc.CallOption) (*Colocation, error)
	// Leave colocation
	LeaveColocation(ctx context.Context, in *LeaveColocationRequest, opts ...grpc.CallOption) (*LeaveColocationResponse, error)
	// Get colocation members
	GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error)
	// Remove member from colocation (admin only)
	RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error)
	// Update member role (admin only)
	UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*ColocationMember, error)
	// Regenerate invite code (admin only)
	RegenerateInviteCode(ctx context.Context, in *RegenerateInviteCodeRequest, opts ...grpc.CallOption) (*RegenerateInviteCodeResponse, error)
	// Send invitation by email
	SendInvitation(ctx context.Context, in *SendInvitationRequest, opts ...grpc.CallOption) (*Invitation, error)
	// List pending invitations for colocation
	ListInvitations(ctx context.Context, in *ListInvitationsRequest, opts ...grpc.CallOption) (*ListInvitationsResponse, error)
	// Cancel invitation
	CancelInvitation(ctx context.Context, in *CancelInvitationRequest, opts ...grpc.CallOption) (*CancelInvitationResponse, error)
}

type colocationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewColocationServiceClient(cc grpc.ClientConnInterface) ColocationServiceClient {
	return &colocationServiceClient{cc}
}

func (c *colocationServiceClient) CreateColocation(ctx context.Context, in *CreateColocationRequest, opts ...grpc.CallOption) (*Colocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Colocation)
	err := c.cc.Invoke(ctx, ColocationService_CreateColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) GetColocation(ctx context.Context, in *GetColocationRequest, opts ...grpc.CallOption) (*Colocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Colocation)
	err := c.cc.Invoke(ctx, ColocationService_GetColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) ListColocations(ctx context.Context, in *ListColocationsRequest, opts ...grpc.CallOption) (*ListColocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListColocationsResponse)
	err := c.cc.Invoke(ctx, ColocationService_ListColocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) UpdateColocation(ctx context.Context, in *UpdateColocationRequest, opts ...grpc.CallOption) (*Colocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Colocation)
	err := c.cc.Invoke(ctx, ColocationService_UpdateColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) DeleteColocation(ctx context.Context, in *DeleteColocationRequest, opts ...grpc.CallOption) (*DeleteColocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteColocationResponse)
	err := c.cc.Invoke(ctx, ColocationService_DeleteColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) JoinColocation(ctx context.Context, in *JoinColocationRequest, opts ...grpc.CallOption) (*Colocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Colocation)
	err := c.cc.Invoke(ctx, ColocationService_JoinColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) LeaveColocation(ctx context.Context, in *LeaveColocationRequest, opts ...grpc.CallOption) (*LeaveColocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveColocationResponse)
	err := c.cc.Invoke(ctx, ColocationService_LeaveColocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMembersResponse)
	err := c.cc.Invoke(ctx, ColocationService_GetMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveMemberResponse)
	err := c.cc.Invoke(ctx, ColocationService_RemoveMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*ColocationMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ColocationMember)
	err := c.cc.Invoke(ctx, ColocationService_UpdateMemberRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) RegenerateInviteCode(ctx context.Context, in *RegenerateInviteCodeRequest, opts ...grpc.CallOption) (*RegenerateInviteCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegenerateInviteCodeResponse)
	err := c.cc.Invoke(ctx, ColocationService_RegenerateInviteCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) SendInvitation(ctx context.Context, in *SendInvitationRequest, opts ...grpc.CallOption) (*Invitation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invitation)
	err := c.cc.Invoke(ctx, ColocationService_SendInvitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) ListInvitations(ctx context.Context, in *ListInvitationsRequest, opts ...grpc.CallOption) (*ListInvitationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInvitationsResponse)
	err := c.cc.Invoke(ctx, ColocationService_ListInvitations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *colocationServiceClient) CancelInvitation(ctx context.Context, in *CancelInvitationRequest, opts ...grpc.CallOption) (*CancelInvitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelInvitationResponse)
	err := c.cc.Invoke(ctx, ColocationService_CancelInvitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ColocationServiceServer is the server API for ColocationService service.
// All implementations must embed UnimplementedColocationServiceServer
// for forward compatibility.
//
// ColocationService handles colocation operations
type ColocationServiceServer interface {
	// Create a new colocation
	CreateColocation(context.Context, *CreateColocationRequest) (*Colocation, error)
	// Get colocation by ID
	GetColocation(context.Context, *GetColocationRequest) (*Colocation, error)
	// List user's colocations
	ListColocations(context.Context, *ListColocationsRequest) (*ListColocationsResponse, error)
	// Update colocation (admin only)
	UpdateColocation(context.Context, *UpdateColocationRequest) (*Colocation, error)
	// Delete colocation (admin only)
	DeleteColocation(context.Context, *DeleteColocationRequest) (*DeleteColocationResponse, error)
	// Join colocation with invite code
	JoinColocation(context.Context, *JoinColocationRequest) (*Colocation, error)
	// Leave colocation
	LeaveColocation(context.Context, *LeaveColocationRequest) (*LeaveColocationResponse, error)
	// Get colocation members
	GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error)
	// Remove member from colocation (admin only)
	RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error)
	// Update member role (admin only)
	UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*ColocationMember, error)
	// Regenerate invite code (admin only)
	RegenerateInviteCode(context.Context, *RegenerateInviteCodeRequest) (*RegenerateInviteCodeResponse, error)
	// Send invitation by email
	SendInvitation(context.Context, *SendInvitationRequest) (*Invitation, error)
	// List pending invitations for colocation
	ListInvitations(context.Context, *ListInvitationsRequest) (*ListInvitationsResponse, error)
	// Cancel invitation
	CancelInvitation(context.Context, *CancelInvitationRequest) (*CancelInvitationResponse, error)
	mustEmbedUnimplementedColocationServiceServer()
}

// UnimplementedColocationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedColocationServiceServer struct{}

func (UnimplementedColocationServiceServer) CreateColocation(context.Context, *CreateColocationRequest) (*Colocation, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateColocation not implemented")
}
func (UnimplementedColocationServiceServer) GetColocation(context.Context, *GetColocationRequest) (*Colocation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetColocation not implemented")
}
func (UnimplementedColocationServiceServer) ListColocations(context.Context, *ListColocationsRequest) (*ListColocationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListColocations not implemented")
}
func (UnimplementedColocationServiceServer) UpdateColocation(context.Context, *UpdateColocationRequest) (*Colocation, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateColocation not implemented")
}
func (UnimplementedColocationServiceServer) DeleteColocation(context.Context, *DeleteColocationRequest) (*DeleteColocationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteColocation not implemented")
}
func (UnimplementedColocationServiceServer) JoinColocation(context.Context, *JoinColocationRequest) (*Colocation, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinColocation not implemented")
}
func (UnimplementedColocationServiceServer) LeaveColocation(context.Context, *LeaveColocationRequest) (*LeaveColocationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LeaveColocation not implemented")
}
func (UnimplementedColocationServiceServer) GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMembers not implemented")
}
func (UnimplementedColocationServiceServer) RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveMember not implemented")
}
func (UnimplementedColocationServiceServer) UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*ColocationMember, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMemberRole not implemented")
}
func (UnimplementedColocationServiceServer) RegenerateInviteCode(context.Context, *RegenerateInviteCodeRequest) (*RegenerateInviteCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegenerateInviteCode not implemented")
}
func (UnimplementedColocationServiceServer) SendInvitation(context.Context, *SendInvitationRequest) (*Invitation, error) {
	return nil, status.Error(codes.Unimplemented, "method SendInvitation not implemented")
}
func (UnimplementedColocationServiceServer) ListInvitations(context.Context, *ListInvitationsRequest) (*ListInvitationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListInvitations not implemented")
}
func (UnimplementedColocationServiceServer) CancelInvitation(context.Context, *CancelInvitationRequest) (*CancelInvitationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelInvitation not implemented")
}
func (UnimplementedColocationServiceServer) mustEmbedUnimplementedColocationServiceServer() {}
func (UnimplementedColocationServiceServer) testEmbeddedByValue()                           {}

// UnsafeColocationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ColocationServiceServer will
// result in compilation errors.
type UnsafeColocationServiceServer interface {
	mustEmbedUnimplementedColocationServiceServer()
}

func RegisterColocationServiceServer(s grpc.ServiceRegistrar, srv ColocationServiceServer) {
	// If the following call panics, it indicates UnimplementedColocationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ColocationService_ServiceDesc, srv)
}

func _ColocationService_CreateColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).CreateColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_CreateColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).CreateColocation(ctx, req.(*CreateColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_GetColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).GetColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_GetColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).GetColocation(ctx, req.(*GetColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_ListColocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListColocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).ListColocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_ListColocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).ListColocations(ctx, req.(*ListColocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_UpdateColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).UpdateColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_UpdateColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).UpdateColocation(ctx, req.(*UpdateColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_DeleteColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).DeleteColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_DeleteColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).DeleteColocation(ctx, req.(*DeleteColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_JoinColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).JoinColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_JoinColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).JoinColocation(ctx, req.(*JoinColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_LeaveColocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveColocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).LeaveColocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_LeaveColocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).LeaveColocation(ctx, req.(*LeaveColocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_GetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).GetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_GetMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).GetMembers(ctx, req.(*GetMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_RemoveMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).RemoveMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_RemoveMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).RemoveMember(ctx, req.(*RemoveMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_UpdateMemberRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMemberRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).UpdateMemberRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_UpdateMemberRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).UpdateMemberRole(ctx, req.(*UpdateMemberRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_RegenerateInviteCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegenerateInviteCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).RegenerateInviteCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_RegenerateInviteCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).RegenerateInviteCode(ctx, req.(*RegenerateInviteCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_SendInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendInvitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).SendInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_SendInvitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).SendInvitation(ctx, req.(*SendInvitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_ListInvitations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvitationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).ListInvitations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_ListInvitations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).ListInvitations(ctx, req.(*ListInvitationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ColocationService_CancelInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelInvitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ColocationServiceServer).CancelInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ColocationService_CancelInvitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ColocationServiceServer).CancelInvitation(ctx, req.(*CancelInvitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ColocationService_ServiceDesc is the grpc.ServiceDesc for ColocationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ColocationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coloc.ColocationService",
	HandlerType: (*ColocationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateColocation",
			Handler:    _ColocationService_CreateColocation_Handler,
		},
		{
			MethodName: "GetColocation",
			Handler:    _ColocationService_GetColocation_Handler,
		},
		{
			MethodName: "ListColocations",
			Handler:    _ColocationService_ListColocations_Handler,
		},
		{
			MethodName: "UpdateColocation",
			Handler:    _ColocationService_UpdateColocation_Handler,
		},
		{
			MethodName: "DeleteColocation",
			Handler:    _ColocationService_DeleteColocation_Handler,
		},
		{
			MethodName: "JoinColocation",
			Handler:    _ColocationService_JoinColocation_Handler,
		},
		{
			MethodName: "LeaveColocation",
			Handler:    _ColocationService_LeaveColocation_Handler,
		},
		{
			MethodName: "GetMembers",
			Handler:    _ColocationService_GetMembers_Handler,
		},
		{
			MethodName: "RemoveMember",
			Handler:    _ColocationService_RemoveMember_Handler,
		},
		{
			MethodName: "UpdateMemberRole",
			Handler:    _ColocationService_UpdateMemberRole_Handler,
		},
		{
			MethodName: "RegenerateInviteCode",
			Handler:    _ColocationService_RegenerateInviteCode_Handler,
		},
		{
			MethodName: "SendInvitation",
			Handler:    _ColocationService_SendInvitation_Handler,
		},
		{
			MethodName: "ListInvitations",
			Handler:    _ColocationService_ListInvitations_Handler,
		},
		{
			MethodName: "CancelInvitation",
			Handler:    _ColocationService_CancelInvitation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "colocation.proto",
}
